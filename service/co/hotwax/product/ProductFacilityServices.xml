<?xml version="1.0" encoding="UTF-8"?>
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://moqui.org/xsd/service-definition-3.xsd">

    <service verb="run" noun="ExportProductFacilityDetail" authenticate="false" transaction-timeout="7200">
        <description>Executes product facility rules.</description>
        <in-parameters>
            <parameter name="ruleGroupId" type="String" required="true"/>
            <parameter name="productStoreId" type="String" required="true"/>
            <parameter name="systemMessageRemoteId" type="String" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.rule.RuleGroup" value-field="ruleGroup">
                <field-map field-name="ruleGroupId" from="ruleGroupId"/>
                <field-map field-name="productStoreId" from="productStoreId"/>
            </entity-find-one>
            <if condition="!ruleGroup">
                <return error="true" message="No rule group found."/>
            </if>

            <service-call name="co.hotwax.product.ProductFacilityServices.build#ruleTemplate"
                    in-map="[ruleGroupId: ruleGroupId]"
                    out-map="templateResult"/>
            <set field="ruleTemplateBytes" from="templateResult.ruleTemplateBytes"/>
            <if condition="!ruleTemplateBytes">
                <return error="true" message="Error in building rule template."/>
            </if>
            <script>
                import org.kie.api.KieServices;
                import org.kie.internal.utils.KieHelper;
                import org.kie.api.io.Resource;
                import org.kie.api.io.ResourceType;
                import org.kie.api.KieBase;
                import org.kie.api.KieServices

                kieServices = KieServices.Factory.get();
                kieHelper = new KieHelper();
                resource = kieServices.getResources().newByteArrayResource(ruleTemplateBytes);
                kieHelper.addResource(resource, ResourceType.DRL);
                kieBase = kieHelper.build();
                kieSession = kieBase.newKieSession();
                productFacilityDetail = [:]
            </script>

            <set field="viewSize" value="1000" type="Integer"/>
            <set field="viewIndex" value="0" type="Integer"/>
            <service-call name="co.hotwax.product.ProductFacilityServices.get#Products"
                          in-map="[viewIndex: viewIndex, viewSize: viewSize]"
                          out-map="productResult"/>
            <if condition="!productResult.productDetail">
                <return error="true" message="No products found."/>
            </if>
            <set field="products" from="productResult.productDetail.products"/>
            <set field="totalProducts" from="productResult.productDetail.totalCount"/>

            <iterate list="products" entry="product">
                <script>
                    kieSession.setGlobal("productFacilityDetail", productFacilityDetail);
                    kieSession.insert(product);
                    int numberOfRulesFired = kieSession.fireAllRules();
                </script>
            </iterate>
            <service-call name="co.hotwax.product.ProductFacilityServices.prepare#ProductFacilityCsv"
                          in-map="[products: productFacilityDetail.values(), systemMessageTypeId: 'ExportProductFacilityDetail']"
                          out-map="result"/>
            <!--The fileName will be used in subsequent calls in order to keep only one CSV file in a single run. So if fileName is passed, data get appended to the existing file-->
            <set field="csvFilePath" from="result.csvFilePath"/>
            <script>
                import co.hotwax.common.CommerceUtil
                paginationValues = CommerceUtil.getPaginationValues(viewSize, 0, totalProducts)
                viewIndexLast = paginationValues.viewIndexLast
                viewIndexList = (1..viewIndexLast).toList()
            </script>
            <iterate list="viewIndexList" entry="viewIndex">
                <service-call name="co.hotwax.product.ProductFacilityServices.get#Products"
                        in-map="[viewIndex: viewIndex*viewSize, viewSize: viewSize]"
                        out-map="productResult"/>
                <if condition="productResult.productDetail">
                    <set field="products" from="productResult.productDetail.products"/>
                    <iterate list="products" entry="product">
                        <script>
                            kieSession.setGlobal("productFacilityDetail", productFacilityDetail);
                            kieSession.insert(product);
                            int numberOfRulesFired = kieSession.fireAllRules();
                        </script>
                    </iterate>
                    <service-call name="co.hotwax.product.ProductFacilityServices.prepare#ProductFacilityCsv"
                            in-map="[products: productFacilityDetail.values(), systemMessageTypeId: 'ExportProductFacilityDetail', csvFilePath: csvFilePath]"
                            out-map="result"/>
                </if>
            </iterate>
            <script>
                kieSession.dispose();
            </script>
            <service-call name="co.hotwax.product.ProductFacilityServices.upload#ProductFacilityCsvToFtp" transaction="force-new"
                    in-map="[filePath: csvFilePath, systemMessageRemoteId: systemMessageRemoteId]"
                    out-map="result"/>

            <log message="Product facility rules executed successfully for rule group [${ruleGroupId}]."/>
        </actions>
    </service>
    <service verb="prepare" noun="ProductFacilityCsv" authenticate="false" transaction-timeout="7200">
        <description>Prepare product facility csv.</description>
        <in-parameters>
            <parameter name="products" type="List" required="true"/>
            <parameter name="csvFilePath" type="String" required="false"/>
            <parameter name="systemMessageTypeId" required="true">
                <description>The System Message Type ID for generating product facility csv.</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="csvFilePath" type="String" required="true"/>
        </out-parameters>
        <actions>
            <if condition="!products">
                <return error="No products found."/>
            </if>
            <set field="nowDate" from="ec.user.nowTimestamp"/>
            <set field="skipHeader" value="Y"/>

            <!-- Fetch the receivePath from SystemMessageType to prepare the path for creating the file in the receiving system. Ex: Moqui's datamanager directory in runtime.-->
            <entity-find-one entity-name="moqui.service.message.SystemMessageType" value-field="systemMessageType"/>

            <if condition="!csvFilePath">
                <set field="csvFilePathRef" from="ec.resource.expand(systemMessageType.receivePath, null,
                        [contentRoot: ec.user.getPreference('mantle.content.root') ?: 'dbresource://datamanager', dateTime:ec.l10n.format(nowDate, 'yyyy-MM-dd-HH-mm-ss-SSS')], false)"/>
                <set field="csvFilePath" from="ec.resource.getLocationReference(csvFilePathRef).getUri().getPath()"/>
                <set field="skipHeader" value="N"/>
            </if>

            <set field="csvTemplateLocation" value="component://available-to-promise/template/ExportProductFacility.csv.ftl"/>

            <!--flag to include/exclude csv header if writing first time or appending the content in the existing file-->
            <script>
                File productFacilityDetailFile = new File(csvFilePath)
                if (!productFacilityDetailFile.parentFile.exists()) productFacilityDetailFile.parentFile.mkdirs()

                Writer writer = new StringWriter()
                ec.resourceFacade.template(csvTemplateLocation, writer)

                data = writer.toString()
                if (data) {
                    try (Writer outFile = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(csvFilePath, true)))) {
                        outFile.append(data);
                    }
                }
            </script>
            <log message="CSV file prepared successfully."/>
        </actions>
    </service>
    <service verb="get" noun="Products" authenticate="false" transaction-timeout="7200">
        <description>Get products</description>
        <in-parameters>
            <parameter name="query" type="String" required="false"/>
            <parameter name="filter" type="String" required="false"/>
            <parameter name="viewIndex" type="Integer" required="false"/>
            <parameter name="viewSize" type="Integer" required="false"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productDetail" type="Map"/>
        </out-parameters>
        <actions>
            <script>
                omsBaseUrl = co.hotwax.util.MaargUtil.getOmsInstanceUrl(ec.ecfi);
                token = co.hotwax.util.MaargUtil.getOmsJwtToken(ec.ecfi);
            </script>
            <if condition="!token">
                <return error="true" message="Unable to generate oms token, check JWT configuration"/>
            </if>
            <if condition="!omsBaseUrl">
                <return error="true" message="OMS base url not found"/>
            </if>

            <script><![CDATA[
                import org.moqui.context.ExecutionContext
                import org.moqui.util.RestClient
                ExecutionContext ec = context.ec

                endPointUri = new StringBuilder()
                endPointUri.append(omsBaseUrl)
                endPointUri.append("/api/solr-query?token=")
                endPointUri.append(token)

                // Construct the JSON structure
                productDetail = [:]

                filterConditions = new StringBuilder()
                filterConditions.append("docType:PRODUCT AND isVirtual:false")
                if (filter) {
                    filterConditions.append(" AND " + filter)
                }
                queryObject = [query: query ?: "*:*", filter: filterConditions.toString(), params: [rows: viewSize ?: 10, start: viewIndex ?: 0]]

                RestClient restClient = ec.service.rest().method("POST").uri(endPointUri.toString())
                restClient.jsonObject([json: queryObject])

                try {
                    RestClient.RestResponse restResponse = restClient.call()

                    if (restResponse.statusCode == 200) {
                        responseMap = (Map) restResponse.jsonObject()
                        productDetail.products = responseMap.response.docs
                        productDetail.totalCount = responseMap.response.numFound
                    } else {
                        ec.message.addMessage("Server error on Solr server: ${restResponse.getReasonPhrase()}")
                    }
                } catch (Exception e) {
                    ec.logger.log(ec.logger.ERROR_INT, "Error calling request at ${restClient.getUri()?.toString()}", e)
                    ec.message.addMessage("Error calling request at ${restClient.getUri()?.toString()}: ${e.toString()}")
                    return
                }
            ]]></script>
            <log message="${viewSize} products are fetched successfully from index ${viewIndex}."/>
        </actions>
    </service>

    <service verb="build" noun="ruleTemplate">
        <in-parameters>
            <parameter name="ruleGroupId" type="String" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="ruleTemplateBytes"/>
        </out-parameters>
        <actions>
            <set field="templateLocation" value="component://available-to-promise/drl/ProductFacilityRuleTemplate.drl.ftl"/>
            <script>
                Writer writer = new StringWriter()
                ec.resourceFacade.template(templateLocation, writer)

                ruleTemplateBytes = writer.toString().getBytes();
                ec.logger.info("Rule Template:" +writer.toString())
            </script>
        </actions>
    </service>
    <service verb="upload" noun="ProductFacilityCsvToFtp" authenticate="false" transaction-timeout="7200">
        <description>Upload product facility csv.</description>
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true">
                <description>The System Message Remote ID to upload product facility csv to ftp location.</description>
            </parameter>
            <parameter name="filePath" type="String" required="true">
                <description>The path of csv file to upload.</description>
            </parameter>
        </in-parameters>
        <actions>
            <if condition="!filePath">
                <return error="No file path found."/>
            </if>
            <service-call name="create#moqui.service.message.SystemMessage" transaction="force-new"
                          in-map="[systemMessageTypeId : 'ExportProductFacilityDetail', systemMessageRemoteId: systemMessageRemoteId, statusId:'SmsgProduced', isOutgoing:'Y', messageText: filePath, initDate:ec.user.nowTimestamp]"
                          out-map="result"/>
            <set field="systemMessageId" from="result.systemMessageId"/>
            <service-call name="co.hotwax.ofbiz.SystemMessageServices.send#SystemMessageFileSftp" transaction="force-new"
                          in-map="[systemMessageId : systemMessageId]"
                          out-map="result"/>
            <service-call name="update#moqui.service.message.SystemMessage" transaction="force-new"
                          in-map="[systemMessageId : systemMessageId, statusId: 'SmsgSent']"
                          out-map="result"/>
            <log message="CSV file uploaded successfully."/>
        </actions>
    </service>
</services>